
/* ============================================================================================== */
/* Base (atomic) values */
/* ============================================================================================== */

/* An integer literal */
int_lit = @{ ("+" | "-")? ~ ASCII_DIGIT+ }

/* A float literal */
num_lit = @{ int_part ~ ("." ~ dec_part)? ~ ((^"e" | ^"E") ~ exp_part)? }
    int_part = _{ int_lit }
    dec_part = _{ int_lit }
    exp_part = _{ int_lit }

/* A token string */
token = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

/* A variable (protects literal device labels as keywords) */
var = @{ dev_base? ~ token }

/* Integers or floats */
int = { int_lit | var }
num = { num_lit | var }

/* A device register (batched or literal, but not a variable) */
dev = _{ dev_lit | var }
    dev_lit = _{ dev_id | dev_batch | dev_base }
        dev_batch = ${ int ~ ".all" }
        dev_base  = ${ "d" ~ "r"* ~ !".all" ~ int_lit }
        dev_id    = ${ "d(" ~ int ~ ")" }

/* ============================================================================================== */
/* L-values and R-values */
/* ============================================================================================== */

/* A device parameter */
param = @{ token }

/* A function call */
func = ${ var ~ "()" }

/* An l-value
 *
 * An l-value is something which persists beyond an expression; that is, an l-value is a location at
 * which we can store a number. An l-value can be a variable or the parameter of a device (or many
 * devices in the case of the network).
 */
l_value = _{ l_param | var }
    /* A device parameter to write to */
    l_param = ${ dev ~ "." ~ param }

/* Modes for batch reading a parameter from devices on the network to an r-value */
batch_mode = _{ batch_avg | batch_sum | batch_min | batch_max }
    /* Batch read modes */
    batch_avg  = { "avg" }
    batch_sum  = { "sum" }
    batch_min  = { "min" }
    batch_max  = { "max" }

/* An r-value
 *
 * An r-value is something which does *not* persist beyond an expression, and ultimately is to be
 * reduced to a number. An r-value can be a literal number, a value copied from a variable, a value
 * read from a device parameter, or an expression of any of the previous.
 */
r_value = { r_value_lit | var }
    r_value_lit = _{ net_param | dev_param | func | "(" ~ expr ~ ")" | num_lit }
        net_param = ${ int ~ "." ~ batch_mode ~ "." ~ param }
        dev_param = ${ dev ~ "." ~ param }

/* ============================================================================================== */
/* Expressions */
/* ============================================================================================== */

/* Operators */
op = _{ u_op | b_op }
    /* Unary operators */
    u_op = _{ inv | not }
        inv = { WHITESPACE* ~ "-" ~ WHITESPACE* }
        not = { WHITESPACE* ~ "!" ~ WHITESPACE* }
    /* Binary math/logical operators */
    b_op = _{ add | sub | mul | div | rem | and | or | xor | eq | ge | gt | le | lt | ne }
        /* Numerical */
        add = { WHITESPACE* ~ "+" ~ WHITESPACE* }
        sub = { WHITESPACE* ~ "-" ~ WHITESPACE* }
        mul = { WHITESPACE* ~ "*" ~ WHITESPACE* }
        div = { WHITESPACE* ~ "/" ~ WHITESPACE* }
        rem = { WHITESPACE* ~ "%" ~ WHITESPACE* }
        /* Logical */
        and = @{ WHITESPACE+ ~ "and" ~ WHITESPACE+ }
        or  = @{ WHITESPACE+ ~ "or"  ~ WHITESPACE+ }
        xor = @{ WHITESPACE+ ~ "xor" ~ WHITESPACE+ }
        /* Relational */
        eq = { WHITESPACE* ~ "==" ~ WHITESPACE* }
        ge = { WHITESPACE* ~ ">=" ~ WHITESPACE* }
        gt = { WHITESPACE* ~ ">"  ~ WHITESPACE* }
        le = { WHITESPACE* ~ "<=" ~ WHITESPACE* }
        lt = { WHITESPACE* ~ "<"  ~ WHITESPACE* }
        ne = { WHITESPACE* ~ "!=" ~ WHITESPACE* }

/* An expression */
expr = _{ t_expr | b_expr | u_expr | r_value }
    /* A unary expression */
    u_expr = ${ u_op ~ r_value }
    /* A binary expression */
    b_expr = ${ r_value ~ (b_op ~ r_value)+ }
    /* A ternary expression (i.e. MIPS `select`) */
    t_expr = { r_value ~ "?" ~ r_value ~ ":" ~ r_value }

/* ============================================================================================== */
/* Program and statements */
/* ============================================================================================== */

/* A branch */
branch = {
    ( branch_loop |
      branch_if |
      branch_elif |
      branch_else |
      branch_while |
      branch_for |
      branch_def
    ) ~ ":"
}
    branch_loop  = !{ "loop" }
    branch_if    = !{ "if" ~ expr }
    branch_elif  = !{ "elif" ~ expr }
    branch_else  = !{ "else" }
    branch_while = !{ "while" ~ expr }
    branch_for   = !{ "for" ~ var ~ "in" ~ expr ~ ":" ~ expr ~ (":" ~ expr)? }
    branch_def   = !{ "def" ~ var }

/* A statement */
stmt = { assign_alias | assign_value | func }
    assign_alias = !{ var ~ "=" ~ dev_lit ~ !("." ~ param)}
    assign_value = !{ l_value ~ "=" ~ expr }

line = { empty | (indent* ~ item ~ WHITESPACE* ~ comment? ~ NEWLINE) }
    empty = { WHITESPACE* ~ WHITESPACE* ~ COMMENT* ~ NEWLINE }
    indent = { "    " }
    item = { branch | stmt }

program = ${
    SOI ~
    line* ~
    EOI
}

comment = @{ COMMENT+ }
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }
WHITESPACE = _{ " " }

/* For tests */
if_line = _{ SOI ~ branch_if ~ NEWLINE }
